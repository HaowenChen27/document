# 什么是OOM，为什么会OOM及一些解决方法



1）<font size=5>**什么是OOM？**</font> OOM，全称“Out Of Memory”，翻译成中文就是“**内存用完了**”，来源于java.lang.OutOfMemoryError。看下关于的官方说明： Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 意思就是说，当JVM因为**没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时**，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。



2）<font size=5>**为什么会OOM？**</font>

 

为什么会没有内存了呢？原因不外乎有两点：

 

1）**分配的少了**：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。

 

2）应用用的太多，并且用完没释放，浪费了。此时就会造成**内存泄露**或者**内存溢出**。

 

<font color=red>内存泄露</font>：**申请使用完的内存没有释放**，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，<font color=red>**因为申请者不用了，而又不能被虚拟机分配给别人用**</font>。



<font color=red>内存溢出</font>：**申请的内存超出了JVM能提供的内存大小**，此时称之为溢出。

 

在之前没有垃圾自动回收的日子里，比如C语言和C++语言，我们必须亲自负责内存的申请与释放操作，如果申请了内存，用完后又忘记了释放，比如C++中的new了但是没有delete，那么就可能造成内存泄露。**偶尔的内存泄露可能不会造成问题，而大量的内存泄露可能会导致内存溢出**。

 

而在Java语言中，由于存在了垃圾自动回收机制，所以，我们一般不用去主动释放不用的对象所占的内存，也就是理论上来说，是不会存在“内存泄露”的。但是，如果编码不当，比如，将某个对象的引用放到了全局的Map中，虽然方法结束了，但是由于**垃圾回收器会根据对象的引用情况来回收内存**，导致该对象不能被及时的回收。如果该种情况出现次数多了，就会导致内存溢出，比如系统中经常使用的缓存机制。<font color=red>Java中的内存泄露，不同于C++中的忘了delete，往往是逻辑上的原因泄露。</font>



3）<font size=5>**OOM的类型**</font>

 

JVM内存模型：

 

按照JVM规范，JAVA虚拟机在运行时会管理以下的内存区域：

**程序计数器**：当前线程执行的字节码的行号指示器，线程私有
**JAVA虚拟机栈**：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。
**本地方法栈**：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。
**JAVA堆**：**对象内存分配的地方**，内存垃圾回收的主要区域，**所有线程共享**。**可分为<mark>新生代，老生代</mark>**。
**方法区**：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。
**运行时常量池**：**方法区的一部分**，存储常量信息，如各种字面量、符号引用等。
**直接内存**：**并不是JVM运行时数据区的一部分**， 可直接访问的内存， 比如NIO会用到这部分。
按照JVM规范，**除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。**



<font color=blue size=5>**引申出问题**</font>

> ## java中的基本数据类型存放位置
>
> 基本数据类型是放在栈中还是放在堆中，<font color=red>这取决于基本类型声明的位置</font>。
>
>  一：<mark>在方法中声明的变量</mark>，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，<font color=red>其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</font>
>
> 在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。
>
> ​     （1）当声明是<mark>**基本类型**</mark>的变量的时，其变量名及值（*变量名及值是两个概念*）是<mark>放在方法栈中</mark>
>
> ​     （2）当声明的是<mark>**引用变量**</mark>时，所声明的<mark>变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中</mark>，**该变量所指向的对象是放在堆类存中的**。
>
> 二：<mark>在类中声明的变量是成员变量，也叫全局变量</mark>，**放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）**。
>
> ​    同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量
>
> ​    （1）当声明的是<mark>基本类型</mark>的变量其变量名及其值放在堆内存中的
>
> ​    （2）<mark>引用类型</mark>时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。<mark>引用变量名和对应的对象仍然存储在相应的堆中</mark>
>
> <font size=5 color=green>**总结：方法中声明的变量，如果是基本类型存在栈中，如果是引用类型变量存在栈中，所指向的对象存在堆中。类中声明的变量（成员变量即全局变量）无论是基本类型还是引用类型都是存在堆中。**</font>



> ## 什么是方法区(永久代)
>
> <mark>保存在着被加载过的每一个类的信息</mark>；这些信息由**类加载器在加载类的时候，从类的源文件中抽取出来**；<mark>static变量信息也保存在方法区中</mark>；
>
> 可以看做是将<mark>类（Class）的元数据</mark>，保存在方法区里；
>
> **方法区是线程共享的**；当有多个线程都用到一个类的时候，而这个类还未被加载，则应该只有一个线程去加载类，让其他线程等待；
>
> 方法区的大小不必是固定的，<mark>jvm可以根据应用的需要动态调整。jvm也可以允许用户和程序指定方法区的初始大小，最小和最大限制；</mark>
>
> **方法区同样存在垃圾收集**，因为通过用户定义的类加载器可以动态扩展Java程序，这样可能会导致一些类，不再被使用，变为垃圾。这时候需要进行垃圾清理。
>
> <font color=red>永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类</font>
>
> 常量的回收
>
> 以常量池中字面量的回收为例,假如一个字符串“abc” 已经进入了常量池中,但是当前系统没有任何一个String对象是叫做“abc”的，换句话说 ,<mark>就是没有任何String对象引用常量池中的“abc”常量 ,也没有其他地方引用了这个字面量</mark>,如果这时发生内存回收,而且必要的话,这个“abc”常量就会被系统清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。
>
> <mark>判定一个常量是否是“废弃常量”比较简单,而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”:</mark>
>
> 1.该类<mark>所有的实例都已经被回收</mark>,也就是Java堆中不存在该类的任何实例。
> 2.<mark>加载该类的ClassLoader已经被回收</mark>。
> 3.<mark>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法。</mark>
>
> 虚拟机可以对满足上述3个条件的无用类进行回收,<mark>这里说的仅仅是“可以”,而并不是和对象一样,不使用了就必然会回收</mark>。是否对类进行回收,HotSpot虚拟机提供了-Xnoclassgc 参数进行控 ,还可以使用-verbose : class以及-XX : +TraceClassLoading、 -XX : +TraceClassUnLoading查看类加载和卸载信息,其中-verbose : class和-XX : +TraceClassLoading可以在Product版的虚拟机中使用, -XX : +TraceClassUnLoading参数需要FastDebug版的虚拟机支持。
>
> <mark>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁 自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出。</mark>



最常见的OOM情况有以下三种：

java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。
java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。
java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在<mark>死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出</mark>。可以通过虚拟机参数-Xss来设置栈的大小。



4）<font size=5>**OOM分析--heapdump**</font>

 

要dump堆的内存镜像，可以采用如下两种方式：

设置JVM参数-XX:+HeapDumpOnOutOfMemoryError，设定当发生OOM时自动dump出堆信息。不过该方法需要JDK5以上版本。
使用JDK自带的jmap命令。"jmap -dump:format=b,file=heap.bin <pid>"   其中pid可以通过jps获取。
dump堆内存信息后，需要对dump出的文件进行分析，从而找到OOM的原因。常用的工具有：

mat: eclipse memory analyzer, 基于eclipse RCP的内存分析工具。详细信息参见：http://www.eclipse.org/mat/，推荐使用。   
jhat：JDK自带的java heap analyze tool，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言OQL，分析相关的应用后，可以通过http://localhost:7000来访问分析结果。不推荐使用，因为在实际的排查过程中，一般是先在生产环境 dump出文件来，然后拉到自己的开发机器上分析，所以，不如采用高级的分析工具比如前面的mat来的高效。
这个链接：http://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html中提供了一个采用mat分析的例子 。

 

注意：因为JVM规范没有对dump出的文件的格式进行定义，所以不同的虚拟机产生的dump文件并不是一样的。在分析时，需要针对不同的虚拟机的输出采用不同的分析工具（当然，有的工具可以兼容多个虚拟机的格式）。IBM HeapAnalyzer也是分析heap的一个常用的工具。

